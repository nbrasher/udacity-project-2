## Problem 3: Huffman Encoding  

For this problem, I created a custom class `Huffman` with `encode` and `decode` functions. The class also has `queue` `tree` and `codes` attributes which hold the priority queue for the Huffman algorithm, the final Huffman tree and the resultant codes for each character in the input string.

The `tree` attribute of the `Huffman` class is a very simple implementation of a binary tree, with code borrowed from the lessons, and one addition. The tree has a `combine` method that allows for linking two binary trees in accordance with the Huffman algorithm. That is, `tree1.combine(tree2)` will create a new tree with a head node assigned a frequency as a sum of the frequency for `tree1` and `tree2` head nodes, and with the left child pointing to `tree1` and the right child pointing to `tree2`. The function `_get_codes` traverses this tree and builds a dict of the resulting codes in order to aid in the encoding process. The decoding process traverses the tree to get the decoded result.

Building the Huffman tree begins with a queue of length n. The algorithm involves working through the entire queue until it is down to a single element, while combining trees at each step. Because of this, there should be ~nlog(n) steps, that is a tree with 4 characters to encode will have 4 child nodes, 2 parent nodes in the next layer, and one root node for 7 total nodes. This complexity will grow like O(nlog(n)). In constrast, the decoding process involves traversing the tree until a child node is found, which in the above example would take only two steps, this process will only grow like O(log(n)). The space complexity of the tree will also be O(nlog(n)) for the same reasons (total number of nodes in the Huffman tree). The other elements of storage (priority queue, dict of codes etc.) are O(n) as there is one element for each code. This the time and space complexity of this algorithm is O(nlog(n)).

In `problem_3.py` I've added a section with `if __name__ == '__main__'` that will run if you run the file in the command line. Each print statement is commented with the expected output. I've also added a few `assert` statements that were used in development to ensure correct behavior.